# 전기화물차 배터리 효율 분석 - Pandas 튜토리얼

이 튜토리얼은 실제 전기화물차 센서 데이터를 분석하는 방법을 단계별로 설명합니다.

---

## 0단계: 라이브러리 설치 및 임포트

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings

warnings.filterwarnings('ignore')

# 한글 폰트 설정 (Windows)
plt.rcParams['font.family'] = 'DejaVu Sans'
# 맥/리눅스는 다음 중 하나 사용
# plt.rcParams['font.family'] = 'AppleGothic'  # Mac
# plt.rcParams['font.family'] = 'NanumGothic'  # Linux
```

---

## 1단계: 데이터 로드 및 기본 탐색

```python
# CSV 파일 로드
df = pd.read_csv('한국교통안전공단_전기화물차 센서데이터_20230807.csv')

# 데이터 기본 정보 확인
print(f"데이터 크기: {df.shape}")  # (행수, 열수)
print(f"\n첫 5행 확인:")
print(df.head())

# 데이터 타입 확인
print(f"\n데이터 타입:")
print(df.dtypes)

# 기본 통계
print(f"\n기본 통계:")
print(df.describe())

# 결측치 확인
print(f"\n결측치 수:")
print(df.isnull().sum())
```

---

## 2단계: 핵심 컬럼 추출 및 정제

```python
# 분석에 필요한 핵심 컬럼만 선택
key_columns = [
    '속도',  # GPS 속도 (km/h)
    '배터리_관리_시스템_고전압_팩_전류',  # 배터리 전류 (A)
    '배터리_관리_시스템_고전압_팩_전압',  # 배터리 전압 (V)
    '배터리_관리_시스템_충전량',  # SOC (State of Charge, %)
    '마이크로컨트롤_유닛_모터_토크_실제',  # 모터 토크 (Nm)
    '차량제어기_액셀',  # 액셀 페달 위치 (%)
    '배터리_관리_시스템_온도01',  # 배터리 온도 (℃)
    '클러스터_주행거리',  # 누적 주행거리
]

# 더 짧은 이름으로 리네이밍 (선택사항)
df_analysis = df[key_columns].copy()
df_analysis.columns = [
    '속도',
    '배터리_전류',
    '배터리_전압',
    'SOC',
    '모터_토크',
    '액셀',
    '배터리_온도',
    '주행거리'
]

print(f"분석 데이터 크기: {df_analysis.shape}")
print(f"\n샘플 데이터:")
print(df_analysis.head(10))

# 데이터 타입 변환 (필요한 경우)
df_analysis['속도'] = pd.to_numeric(df_analysis['속도'], errors='coerce')
df_analysis['배터리_전류'] = pd.to_numeric(df_analysis['배터리_전류'], errors='coerce')
df_analysis['배터리_전압'] = pd.to_numeric(df_analysis['배터리_전압'], errors='coerce')

# 결측치 제거
df_analysis = df_analysis.dropna(subset=['속도', '배터리_전류', '배터리_전압'])

print(f"\n정제 후 데이터 크기: {df_analysis.shape}")
```

---

## 3단계: 새로운 파생 변수 생성

```python
# 1. 순간 전력 계산 (W = V × A)
df_analysis['순간_전력_W'] = df_analysis['배터리_전압'] * df_analysis['배터리_전류']
df_analysis['순간_전력_kW'] = df_analysis['순간_전력_W'] / 1000

# 2. 속도 구간 분류
df_analysis['속도_구간'] = pd.cut(
    df_analysis['속도'],
    bins=[-1, 5, 15, 25, 35, 50, 100],
    labels=['정차(0-5)', '저속(5-15)', '중저속(15-25)', '중속(25-35)', '중고속(35-50)', '고속(50+)']
)

# 3. 속도 변화율 계산
df_analysis['속도_변화'] = df_analysis['속도'].diff()

# 4. 주행 상태 분류 (가속/정속/감속/정차)
def classify_driving_state(speed, speed_change):
    if speed < 1:
        return '정차'
    elif speed_change is np.nan:
        return '정속'
    elif speed_change > 2:
        return '가속'
    elif speed_change < -2:
        return '감속'
    else:
        return '정속'

df_analysis['주행_상태'] = df_analysis.apply(
    lambda row: classify_driving_state(row['속도'], row['속도_변화']),
    axis=1
)

# 5. 액셀 강도 분류
df_analysis['가속_강도'] = pd.cut(
    df_analysis['액셀'],
    bins=[-1, 20, 50, 80, 101],
    labels=['약(0-20%)', '중(20-50%)', '강(50-80%)', '급(80-100%)']
)

# 6. 충전/방전 상태 분류
df_analysis['전류_상태'] = df_analysis['배터리_전류'].apply(
    lambda x: '방전(양수)' if x > 5 else ('회생(음수)' if x < -5 else '대기')
)

print("파생 변수 생성 완료!")
print(f"\n생성된 컬럼:")
print(df_analysis.columns.tolist())

print(f"\n샘플 데이터 (파생 변수 포함):")
print(df_analysis[['속도', '배터리_전류', '순간_전력_kW', '속도_구간', '주행_상태']].head(10))
```

---

## 4단계: 속도 구간별 분석

```python
# 그룹화 및 통계 계산
speed_analysis = df_analysis.groupby('속도_구간').agg({
    '속도': ['count', 'mean', 'min', 'max', 'std'],
    '배터리_전류': ['mean', 'min', 'max', 'std'],
    '순간_전력_kW': ['mean', 'min', 'max'],
    '배터리_온도': 'mean',
    '액셀': 'mean'
}).round(2)

print("\n" + "="*80)
print("속도 구간별 분석")
print("="*80)
print(speed_analysis)

# 컬럼 이름 간단하게 (선택사항)
speed_analysis.columns = ['_'.join(col).strip() for col in speed_analysis.columns]

# CSV로 저장
speed_analysis.to_csv('속도구간별_분석.csv', encoding='utf-8-sig')
print("\n✅ 저장: 속도구간별_분석.csv")
```

---

## 5단계: 주행 상태별 분석

```python
# 주행 상태별 그룹화
state_analysis = df_analysis.groupby('주행_상태').agg({
    '속도': ['count', 'mean', 'std'],
    '배터리_전류': ['mean', 'std'],
    '순간_전력_kW': ['mean', 'std'],
    '액셀': 'mean'
}).round(2)

print("\n" + "="*80)
print("주행 상태별 분석")
print("="*80)
print(state_analysis)

state_analysis.to_csv('주행상태별_분석.csv', encoding='utf-8-sig')
print("\n✅ 저장: 주행상태별_분석.csv")

# 상세 출력
for state in ['정차', '가속', '정속', '감속']:
    state_data = df_analysis[df_analysis['주행_상태'] == state]
    if len(state_data) > 0:
        print(f"\n📌 {state}:")
        print(f"   샘플 수: {len(state_data)}")
        print(f"   평균 속도: {state_data['속도'].mean():.2f} km/h")
        print(f"   평균 전류: {state_data['배터리_전류'].mean():.2f} A")
        print(f"   평균 전력: {state_data['순간_전력_kW'].mean():.2f} kW")
```

---

    ## 6단계: 회생 제동 분석

    ```python
    # 회생 제동 데이터 추출 (음수 전류)
    regen_data = df_analysis[df_analysis['배터리_전류'] < -5].copy()

    print("\n" + "="*80)
    print("회생 제동 분석")
    print("="*80)
    print(f"회생 제동 발생 횟수: {len(regen_data)}")

    if len(regen_data) > 0:
        print(f"평균 속도: {regen_data['속도'].mean():.2f} km/h")
        print(f"평균 회생 전류: {regen_data['배터리_전류'].mean():.2f} A")
        print(f"평균 회생 전력: {regen_data['순간_전력_kW'].mean():.2f} kW")
        print(f"최대 회생 전류: {regen_data['배터리_전류'].min():.2f} A")
        print(f"총 회생 에너지: {regen_data['순간_전력_kW'].sum():.2f} kWh")
        
        # 속도 구간별 회생 분석
        regen_by_speed = regen_data.groupby('속도_구간')['배터리_전류'].agg(['count', 'mean', 'min'])
        print(f"\n속도 구간별 회생 제동:")
        print(regen_by_speed)
    ```

---

## 7단계: 액셀 강도별 분석

```python
# 방전 상태(양수 전류)에서만 액셀 강도 분석
discharge_data = df_analysis[df_analysis['배터리_전류'] > 5].copy()

accel_analysis = discharge_data.groupby('가속_강도').agg({
    '속도': ['count', 'mean'],
    '배터리_전류': ['mean', 'std'],
    '순간_전력_kW': ['mean', 'std'],
    '액셀': 'mean'
}).round(2)

print("\n" + "="*80)
print("액셀 강도별 배터리 소모")
print("="*80)
print(accel_analysis)

accel_analysis.to_csv('액셀강도별_분석.csv', encoding='utf-8-sig')
print("\n✅ 저장: 액셀강도별_분석.csv")

# 상세 통계
for accel in ['약(0-20%)', '중(20-50%)', '강(50-80%)', '급(80-100%)']:
    accel_data = discharge_data[discharge_data['가속_강도'] == accel]
    if len(accel_data) > 0:
        increase = ((accel_data['순간_전력_kW'].mean() - 
                    discharge_data.groupby('가속_강도')['순간_전력_kW'].mean().min()) /
                   discharge_data.groupby('가속_강도')['순간_전력_kW'].mean().min() * 100)
        print(f"\n액셀 {accel}: {accel_data['순간_전력_kW'].mean():.2f} kW")
```

---

## 8단계: 상관관계 분석

```python
# 숫자형 컬럼만 선택
numeric_cols = df_analysis[['속도', '배터리_전류', '배터리_전압', 'SOC', 
                             '모터_토크', '액셀', '배터리_온도', '순간_전력_kW']].copy()

# 상관계수 계산
correlation_matrix = numeric_cols.corr()

print("\n" + "="*80)
print("변수 간 상관관계")
print("="*80)
print(correlation_matrix.round(3))

# 배터리 전류와 다른 변수들의 상관관계
print(f"\n배터리 전류와 다른 변수의 상관관계:")
print(correlation_matrix['배터리_전류'].sort_values(ascending=False))

# 순간 전력과 다른 변수들의 상관관계
print(f"\n순간 전력과 다른 변수의 상관관계:")
print(correlation_matrix['순간_전력_kW'].sort_values(ascending=False))
```

---

## 9단계: 시각화

```python
# 1. 속도 구간별 전력 소모
fig, ax = plt.subplots(figsize=(10, 6))
speed_power = df_analysis.groupby('속도_구간')['순간_전력_kW'].mean()
colors = ['red' if x > 10 else 'green' if x < 5 else 'orange' for x in speed_power.values]
speed_power.plot(kind='bar', ax=ax, color=colors)
ax.set_title('속도 구간별 평균 전력 소모')
ax.set_xlabel('속도 구간')
ax.set_ylabel('평균 전력 (kW)')
ax.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.savefig('속도_전력_소모.png', dpi=100)
plt.show()

# 2. 주행 상태별 배터리 전류
fig, ax = plt.subplots(figsize=(10, 6))
state_current = df_analysis.groupby('주행_상태')['배터리_전류'].mean()
state_current.plot(kind='bar', ax=ax, color='skyblue')
ax.set_title('주행 상태별 평균 배터리 전류')
ax.set_xlabel('주행 상태')
ax.set_ylabel('배터리 전류 (A)')
ax.grid(axis='y', alpha=0.3)
plt.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
plt.tight_layout()
plt.savefig('주행상태_배터리전류.png', dpi=100)
plt.show()

# 3. 속도 vs 순간 전력 산점도
fig, ax = plt.subplots(figsize=(10, 6))
ax.scatter(df_analysis['속도'], df_analysis['순간_전력_kW'], alpha=0.6)
ax.set_title('속도 vs 순간 전력 소모')
ax.set_xlabel('속도 (km/h)')
ax.set_ylabel('순간 전력 (kW)')
ax.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('속도_vs_전력.png', dpi=100)
plt.show()

# 4. 액셀 강도별 전력 소모
fig, ax = plt.subplots(figsize=(10, 6))
accel_power = discharge_data.groupby('가속_강도')['순간_전력_kW'].mean()
accel_power.plot(kind='bar', ax=ax, color='coral')
ax.set_title('액셀 강도별 평균 전력 소모')
ax.set_xlabel('액셀 강도')
ax.set_ylabel('평균 전력 (kW)')
ax.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.savefig('액셀강도_전력.png', dpi=100)
plt.show()

print("✅ 모든 그래프 저장 완료!")
```

---

## 10단계: 최종 요약 보고서 생성

```python
# 주요 지표 계산
optimal_speed_range = (25, 35)
optimal_power = df_analysis[
    (df_analysis['속도'] >= optimal_speed_range[0]) & 
    (df_analysis['속도'] <= optimal_speed_range[1])
]['순간_전력_kW'].mean()

high_speed_power = df_analysis[df_analysis['속도'] >= 35]['순간_전력_kW'].mean()
acceleration_efficiency = (optimal_power / high_speed_power) * 100

# 회생 제동 효과
total_regen = abs(regen_data['순간_전력_kW'].sum())
total_discharge = df_analysis[df_analysis['배터리_전류'] > 5]['순간_전력_kW'].sum()
regen_efficiency = (total_regen / (total_regen + total_discharge)) * 100

# 보고서 작성
report = f"""
{'='*80}
전기화물차 배터리 효율 분석 최종 보고서
{'='*80}

데이터 기간: {df_analysis['속도'].count()}개 샘플
속도 범위: {df_analysis['속도'].min():.2f} ~ {df_analysis['속도'].max():.2f} km/h

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 핵심 발견사항

1. 최적 속도 범위
   • 권장 범위: {optimal_speed_range[0]}-{optimal_speed_range[1]} km/h
   • 평균 전력 소모: {optimal_power:.2f} kW
   • 고속(35+ km/h) 대비 효율: {acceleration_efficiency:.1f}%

2. 회생 제동 효과
   • 회생 제동 발생: {len(regen_data)}회
   • 총 회생 에너지: {total_regen:.2f} kWh
   • 전체 에너지의 {regen_efficiency:.1f}%

3. 액셀 강도별 분석
   • 중간 강도(20-50%): {discharge_data[discharge_data['가속_강도']=='중(20-50%)']['순간_전력_kW'].mean():.2f} kW
   • 강한 강도(50-80%): {discharge_data[discharge_data['가속_강도']=='강(50-80%)']['순간_전력_kW'].mean():.2f} kW
   • 급가속(80-100%): {discharge_data[discharge_data['가속_강도']=='급(80-100%)']['순간_전력_kW'].mean():.2f} kW

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 권장사항

✓ 즉시 실천
  • {optimal_speed_range[0]}-{optimal_speed_range[1]} km/h로 속도 유지
  • 액셀 부드럽게 조작 (20-50% 강도)
  • 회생 제동 적극 활용

✓ 기대 효과
  • 배터리 효율 15-25% 개선
  • 주행거리 연장
  • 배터리 수명 증대

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""

print(report)

# 보고서 저장
with open('최종_분석보고서.txt', 'w', encoding='utf-8') as f:
    f.write(report)

print("✅ 보고서 저장: 최종_분석보고서.txt")
```

---

## 전체 코드 실행 순서

```python
# 한 번에 모든 단계 실행하려면 이 순서대로 진행하세요

# 1. 라이브러리 임포트
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# 2. 데이터 로드
df = pd.read_csv('한국교통안전공단_전기화물차 센서데이터_20230807.csv')

# 3. 핵심 컬럼 추출 및 정제
key_columns = ['속도', '배터리_관리_시스템_고전압_팩_전류', ...]
df_analysis = df[key_columns].copy()

# 4. 파생 변수 생성
df_analysis['순간_전력_kW'] = ...
df_analysis['속도_구간'] = ...

# 5-10. 분석 수행

# 각 단계별 코드는 위에 상세히 설명되어 있습니다!
```

---

## 주요 Pandas 함수 정리

| 함수 | 설명 | 예제 |
|------|------|------|
| `read_csv()` | CSV 파일 로드 | `df = pd.read_csv('file.csv')` |
| `head()` | 처음 n행 표시 | `df.head(10)` |
| `describe()` | 기본 통계 | `df.describe()` |
| `groupby()` | 그룹화 | `df.groupby('col').mean()` |
| `agg()` | 집계 함수 | `df.groupby('col').agg({'col2': 'mean'})` |
| `apply()` | 함수 적용 | `df['col'].apply(lambda x: x*2)` |
| `cut()` | 범주형 변수 생성 | `pd.cut(df['speed'], bins=5)` |
| `to_csv()` | CSV 저장 | `df.to_csv('output.csv')` |
| `corr()` | 상관계수 | `df.corr()` |

---

## 트러블슈팅

**Q1: 한글 컬럼명이 깨짐**
```python
# 파일 로드 시 인코딩 지정
df = pd.read_csv('file.csv', encoding='utf-8')
```

**Q2: 숫자로 변환되지 않는 컬럼**
```python
# 강제 변환
df['col'] = pd.to_numeric(df['col'], errors='coerce')
```

**Q3: NaN 값 처리**
```python
# 제거
df = df.dropna()

# 특정 값으로 채우기
df = df.fillna(0)
```

**Q4: 그래프 저장 안됨**
```python
# 반드시 plt.show() 전에 저장
plt.savefig('output.png', dpi=100, bbox_inches='tight')
plt.show()
```

---

이제 이 코드를 따라하며 자신의 데이터로 분석해보세요! 🚀
